/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */
import type {
  BaseContract,
  BigNumber,
  BigNumberish,
  BytesLike,
  CallOverrides,
  ContractTransaction,
  Overrides,
  PayableOverrides,
  PopulatedTransaction,
  Signer,
  utils,
} from "ethers";
import type {
  FunctionFragment,
  Result,
  EventFragment,
} from "@ethersproject/abi";
import type { Listener, Provider } from "@ethersproject/providers";
import type {
  TypedEventFilter,
  TypedEvent,
  TypedListener,
  OnEvent,
  PromiseOrValue,
} from "./common";

export declare namespace PoolHedger {
  export type PoolHedgerParametersStruct = {
    interactionDelay: PromiseOrValue<BigNumberish>;
    hedgeCap: PromiseOrValue<BigNumberish>;
  };

  export type PoolHedgerParametersStructOutput = [BigNumber, BigNumber] & {
    interactionDelay: BigNumber;
    hedgeCap: BigNumber;
  };
}

export declare namespace IFuturesPoolHedger {
  export type FuturesPoolHedgerParametersStruct = {
    maximumDelta: PromiseOrValue<BigNumberish>;
    maximumFundingRatePerDelta: PromiseOrValue<BigNumberish>;
    deltaThreshold: PromiseOrValue<BigNumberish>;
    marketDepthBuffer: PromiseOrValue<BigNumberish>;
    minKeeperGas: PromiseOrValue<BigNumberish>;
  };

  export type FuturesPoolHedgerParametersStructOutput = [
    BigNumber,
    BigNumber,
    BigNumber,
    BigNumber,
    BigNumber
  ] & {
    maximumDelta: BigNumber;
    maximumFundingRatePerDelta: BigNumber;
    deltaThreshold: BigNumber;
    marketDepthBuffer: BigNumber;
    minKeeperGas: BigNumber;
  };
}

export interface GMXFuturesPoolHedgerInterface extends utils.Interface {
  functions: {
    "acceptOwnership()": FunctionFragment;
    "canHedge(uint256,bool)": FunctionFragment;
    "futuresPoolHedgerParams()": FunctionFragment;
    "getCappedExpectedHedge()": FunctionFragment;
    "getCurrentHedgedNetDelta()": FunctionFragment;
    "getExecutionFee()": FunctionFragment;
    "getHedgingLiquidity(uint256)": FunctionFragment;
    "getPoolHedgerParams()": FunctionFragment;
    "getPosition()": FunctionFragment;
    "gmxPositionCallback(bytes32,bool,bool)": FunctionFragment;
    "greekCache()": FunctionFragment;
    "hedgeDelta()": FunctionFragment;
    "indexToken()": FunctionFragment;
    "init(address,address,address,address,address,address,address,address)": FunctionFragment;
    "isLong()": FunctionFragment;
    "lastInteraction()": FunctionFragment;
    "nominateNewOwner(address)": FunctionFragment;
    "nominatedOwner()": FunctionFragment;
    "orderQueue(uint256)": FunctionFragment;
    "owner()": FunctionFragment;
    "processQueue()": FunctionFragment;
    "quoteAsset()": FunctionFragment;
    "reader()": FunctionFragment;
    "resetInteractionDelay()": FunctionFragment;
    "router()": FunctionFragment;
    "setFuturesPoolHedgerParameters((uint256,int256,uint256,uint256,uint256))": FunctionFragment;
    "setMaxLeverage(uint256)": FunctionFragment;
    "setPoolHedgerParams((uint256,uint256))": FunctionFragment;
    "targetLeverage()": FunctionFragment;
    "tradingFee()": FunctionFragment;
    "updateCollateral()": FunctionFragment;
    "vault()": FunctionFragment;
    "vaultUtils()": FunctionFragment;
  };

  getFunction(
    nameOrSignatureOrTopic:
      | "acceptOwnership"
      | "canHedge"
      | "futuresPoolHedgerParams"
      | "getCappedExpectedHedge"
      | "getCurrentHedgedNetDelta"
      | "getExecutionFee"
      | "getHedgingLiquidity"
      | "getPoolHedgerParams"
      | "getPosition"
      | "gmxPositionCallback"
      | "greekCache"
      | "hedgeDelta"
      | "indexToken"
      | "init"
      | "isLong"
      | "lastInteraction"
      | "nominateNewOwner"
      | "nominatedOwner"
      | "orderQueue"
      | "owner"
      | "processQueue"
      | "quoteAsset"
      | "reader"
      | "resetInteractionDelay"
      | "router"
      | "setFuturesPoolHedgerParameters"
      | "setMaxLeverage"
      | "setPoolHedgerParams"
      | "targetLeverage"
      | "tradingFee"
      | "updateCollateral"
      | "vault"
      | "vaultUtils"
  ): FunctionFragment;

  encodeFunctionData(
    functionFragment: "acceptOwnership",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "canHedge",
    values: [PromiseOrValue<BigNumberish>, PromiseOrValue<boolean>]
  ): string;
  encodeFunctionData(
    functionFragment: "futuresPoolHedgerParams",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "getCappedExpectedHedge",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "getCurrentHedgedNetDelta",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "getExecutionFee",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "getHedgingLiquidity",
    values: [PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "getPoolHedgerParams",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "getPosition",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "gmxPositionCallback",
    values: [
      PromiseOrValue<BytesLike>,
      PromiseOrValue<boolean>,
      PromiseOrValue<boolean>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "greekCache",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "hedgeDelta",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "indexToken",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "init",
    values: [
      PromiseOrValue<string>,
      PromiseOrValue<string>,
      PromiseOrValue<string>,
      PromiseOrValue<string>,
      PromiseOrValue<string>,
      PromiseOrValue<string>,
      PromiseOrValue<string>,
      PromiseOrValue<string>
    ]
  ): string;
  encodeFunctionData(functionFragment: "isLong", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "lastInteraction",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "nominateNewOwner",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "nominatedOwner",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "orderQueue",
    values: [PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(functionFragment: "owner", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "processQueue",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "quoteAsset",
    values?: undefined
  ): string;
  encodeFunctionData(functionFragment: "reader", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "resetInteractionDelay",
    values?: undefined
  ): string;
  encodeFunctionData(functionFragment: "router", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "setFuturesPoolHedgerParameters",
    values: [IFuturesPoolHedger.FuturesPoolHedgerParametersStruct]
  ): string;
  encodeFunctionData(
    functionFragment: "setMaxLeverage",
    values: [PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "setPoolHedgerParams",
    values: [PoolHedger.PoolHedgerParametersStruct]
  ): string;
  encodeFunctionData(
    functionFragment: "targetLeverage",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "tradingFee",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "updateCollateral",
    values?: undefined
  ): string;
  encodeFunctionData(functionFragment: "vault", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "vaultUtils",
    values?: undefined
  ): string;

  decodeFunctionResult(
    functionFragment: "acceptOwnership",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "canHedge", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "futuresPoolHedgerParams",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getCappedExpectedHedge",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getCurrentHedgedNetDelta",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getExecutionFee",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getHedgingLiquidity",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getPoolHedgerParams",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getPosition",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "gmxPositionCallback",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "greekCache", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "hedgeDelta", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "indexToken", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "init", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "isLong", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "lastInteraction",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "nominateNewOwner",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "nominatedOwner",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "orderQueue", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "owner", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "processQueue",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "quoteAsset", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "reader", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "resetInteractionDelay",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "router", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "setFuturesPoolHedgerParameters",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "setMaxLeverage",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "setPoolHedgerParams",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "targetLeverage",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "tradingFee", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "updateCollateral",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "vault", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "vaultUtils", data: BytesLike): Result;

  events: {
    "ApprovalsUpdated(bool)": EventFragment;
    "CollateralOrderPosted(bytes32)": EventFragment;
    "CollateralUpdated(uint256,uint256)": EventFragment;
    "GasLimitToLow(uint256)": EventFragment;
    "MaxLeverageSet(uint256)": EventFragment;
    "MultiplePositionsOpen(uint256)": EventFragment;
    "OrderExecuted(bytes32,bool,bool)": EventFragment;
    "OrderPosted(bytes32,uint256,uint256,bool,bool,bool)": EventFragment;
    "OwnerChanged(address,address)": EventFragment;
    "OwnerNominated(address)": EventFragment;
    "PoolHedgerParametersSet(tuple)": EventFragment;
    "PositionUpdated(int256,int256,int256)": EventFragment;
    "QueueNotEmpty(uint256)": EventFragment;
    "QuoteReturnedToLP(uint256)": EventFragment;
  };

  getEvent(nameOrSignatureOrTopic: "ApprovalsUpdated"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "CollateralOrderPosted"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "CollateralUpdated"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "GasLimitToLow"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "MaxLeverageSet"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "MultiplePositionsOpen"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "OrderExecuted"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "OrderPosted"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "OwnerChanged"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "OwnerNominated"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "PoolHedgerParametersSet"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "PositionUpdated"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "QueueNotEmpty"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "QuoteReturnedToLP"): EventFragment;
}

export interface ApprovalsUpdatedEventObject {
  state: boolean;
}
export type ApprovalsUpdatedEvent = TypedEvent<
  [boolean],
  ApprovalsUpdatedEventObject
>;

export type ApprovalsUpdatedEventFilter =
  TypedEventFilter<ApprovalsUpdatedEvent>;

export interface CollateralOrderPostedEventObject {
  positionKey: string;
}
export type CollateralOrderPostedEvent = TypedEvent<
  [string],
  CollateralOrderPostedEventObject
>;

export type CollateralOrderPostedEventFilter =
  TypedEventFilter<CollateralOrderPostedEvent>;

export interface CollateralUpdatedEventObject {
  newCollat: BigNumber;
  oldCollat: BigNumber;
}
export type CollateralUpdatedEvent = TypedEvent<
  [BigNumber, BigNumber],
  CollateralUpdatedEventObject
>;

export type CollateralUpdatedEventFilter =
  TypedEventFilter<CollateralUpdatedEvent>;

export interface GasLimitToLowEventObject {
  gasLimit: BigNumber;
}
export type GasLimitToLowEvent = TypedEvent<
  [BigNumber],
  GasLimitToLowEventObject
>;

export type GasLimitToLowEventFilter = TypedEventFilter<GasLimitToLowEvent>;

export interface MaxLeverageSetEventObject {
  newShortBuffer: BigNumber;
}
export type MaxLeverageSetEvent = TypedEvent<
  [BigNumber],
  MaxLeverageSetEventObject
>;

export type MaxLeverageSetEventFilter = TypedEventFilter<MaxLeverageSetEvent>;

export interface MultiplePositionsOpenEventObject {
  length: BigNumber;
}
export type MultiplePositionsOpenEvent = TypedEvent<
  [BigNumber],
  MultiplePositionsOpenEventObject
>;

export type MultiplePositionsOpenEventFilter =
  TypedEventFilter<MultiplePositionsOpenEvent>;

export interface OrderExecutedEventObject {
  positionKey: string;
  isExecuted: boolean;
  isIncrease: boolean;
}
export type OrderExecutedEvent = TypedEvent<
  [string, boolean, boolean],
  OrderExecutedEventObject
>;

export type OrderExecutedEventFilter = TypedEventFilter<OrderExecutedEvent>;

export interface OrderPostedEventObject {
  positionKey: string;
  collateralDelta: BigNumber;
  sizeDelta: BigNumber;
  isLong: boolean;
  usedBase: boolean;
  isIncrease: boolean;
}
export type OrderPostedEvent = TypedEvent<
  [string, BigNumber, BigNumber, boolean, boolean, boolean],
  OrderPostedEventObject
>;

export type OrderPostedEventFilter = TypedEventFilter<OrderPostedEvent>;

export interface OwnerChangedEventObject {
  oldOwner: string;
  newOwner: string;
}
export type OwnerChangedEvent = TypedEvent<
  [string, string],
  OwnerChangedEventObject
>;

export type OwnerChangedEventFilter = TypedEventFilter<OwnerChangedEvent>;

export interface OwnerNominatedEventObject {
  newOwner: string;
}
export type OwnerNominatedEvent = TypedEvent<
  [string],
  OwnerNominatedEventObject
>;

export type OwnerNominatedEventFilter = TypedEventFilter<OwnerNominatedEvent>;

export interface PoolHedgerParametersSetEventObject {
  poolHedgerParams: PoolHedger.PoolHedgerParametersStructOutput;
}
export type PoolHedgerParametersSetEvent = TypedEvent<
  [PoolHedger.PoolHedgerParametersStructOutput],
  PoolHedgerParametersSetEventObject
>;

export type PoolHedgerParametersSetEventFilter =
  TypedEventFilter<PoolHedgerParametersSetEvent>;

export interface PositionUpdatedEventObject {
  oldNetDelta: BigNumber;
  currentNetDelta: BigNumber;
  expectedNetDelta: BigNumber;
}
export type PositionUpdatedEvent = TypedEvent<
  [BigNumber, BigNumber, BigNumber],
  PositionUpdatedEventObject
>;

export type PositionUpdatedEventFilter = TypedEventFilter<PositionUpdatedEvent>;

export interface QueueNotEmptyEventObject {
  length: BigNumber;
}
export type QueueNotEmptyEvent = TypedEvent<
  [BigNumber],
  QueueNotEmptyEventObject
>;

export type QueueNotEmptyEventFilter = TypedEventFilter<QueueNotEmptyEvent>;

export interface QuoteReturnedToLPEventObject {
  amountQuote: BigNumber;
}
export type QuoteReturnedToLPEvent = TypedEvent<
  [BigNumber],
  QuoteReturnedToLPEventObject
>;

export type QuoteReturnedToLPEventFilter =
  TypedEventFilter<QuoteReturnedToLPEvent>;

export interface GMXFuturesPoolHedger extends BaseContract {
  connect(signerOrProvider: Signer | Provider | string): this;
  attach(addressOrName: string): this;
  deployed(): Promise<this>;

  interface: GMXFuturesPoolHedgerInterface;

  queryFilter<TEvent extends TypedEvent>(
    event: TypedEventFilter<TEvent>,
    fromBlockOrBlockhash?: string | number | undefined,
    toBlock?: string | number | undefined
  ): Promise<Array<TEvent>>;

  listeners<TEvent extends TypedEvent>(
    eventFilter?: TypedEventFilter<TEvent>
  ): Array<TypedListener<TEvent>>;
  listeners(eventName?: string): Array<Listener>;
  removeAllListeners<TEvent extends TypedEvent>(
    eventFilter: TypedEventFilter<TEvent>
  ): this;
  removeAllListeners(eventName?: string): this;
  off: OnEvent<this>;
  on: OnEvent<this>;
  once: OnEvent<this>;
  removeListener: OnEvent<this>;

  functions: {
    acceptOwnership(
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    canHedge(
      poolDeltaChange: PromiseOrValue<BigNumberish>,
      deltaIncrease: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    futuresPoolHedgerParams(
      overrides?: CallOverrides
    ): Promise<
      [BigNumber, BigNumber, BigNumber, BigNumber, BigNumber] & {
        maximumDelta: BigNumber;
        maximumFundingRatePerDelta: BigNumber;
        deltaThreshold: BigNumber;
        marketDepthBuffer: BigNumber;
        minKeeperGas: BigNumber;
      }
    >;

    getCappedExpectedHedge(overrides?: CallOverrides): Promise<[BigNumber]>;

    getCurrentHedgedNetDelta(overrides?: CallOverrides): Promise<[BigNumber]>;

    getExecutionFee(overrides?: CallOverrides): Promise<[BigNumber]>;

    getHedgingLiquidity(
      spotPrice: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<
      [BigNumber, BigNumber] & {
        pendingDeltaLiquidity: BigNumber;
        usedDeltaLiquidity: BigNumber;
      }
    >;

    getPoolHedgerParams(
      overrides?: CallOverrides
    ): Promise<[PoolHedger.PoolHedgerParametersStructOutput]>;

    getPosition(overrides?: CallOverrides): Promise<[BigNumber[]]>;

    gmxPositionCallback(
      positionKey: PromiseOrValue<BytesLike>,
      isExecuted: PromiseOrValue<boolean>,
      isIncrease: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    greekCache(overrides?: CallOverrides): Promise<[string]>;

    hedgeDelta(
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    indexToken(overrides?: CallOverrides): Promise<[string]>;

    init(
      _liquidityPool: PromiseOrValue<string>,
      _greekCache: PromiseOrValue<string>,
      _router: PromiseOrValue<string>,
      _reader: PromiseOrValue<string>,
      _baseRouter: PromiseOrValue<string>,
      _vaultUtils: PromiseOrValue<string>,
      _quoteAsset: PromiseOrValue<string>,
      _indexToken: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    isLong(overrides?: CallOverrides): Promise<[boolean]>;

    lastInteraction(overrides?: CallOverrides): Promise<[BigNumber]>;

    nominateNewOwner(
      _owner: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    nominatedOwner(overrides?: CallOverrides): Promise<[string]>;

    orderQueue(
      arg0: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<
      [boolean, BigNumber, BigNumber, boolean, number, boolean, string] & {
        isIncrease: boolean;
        collateralDelta: BigNumber;
        sizeDelta: BigNumber;
        long: boolean;
        status: number;
        useBase: boolean;
        key: string;
      }
    >;

    owner(overrides?: CallOverrides): Promise<[string]>;

    processQueue(
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    quoteAsset(overrides?: CallOverrides): Promise<[string]>;

    reader(overrides?: CallOverrides): Promise<[string]>;

    resetInteractionDelay(
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    router(overrides?: CallOverrides): Promise<[string]>;

    setFuturesPoolHedgerParameters(
      _futuresPoolHedgerParams: IFuturesPoolHedger.FuturesPoolHedgerParametersStruct,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    setMaxLeverage(
      _targetLeverage: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    setPoolHedgerParams(
      _poolHedgerParams: PoolHedger.PoolHedgerParametersStruct,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    targetLeverage(overrides?: CallOverrides): Promise<[BigNumber]>;

    tradingFee(overrides?: CallOverrides): Promise<[BigNumber]>;

    updateCollateral(
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    vault(overrides?: CallOverrides): Promise<[string]>;

    vaultUtils(overrides?: CallOverrides): Promise<[string]>;
  };

  acceptOwnership(
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  canHedge(
    poolDeltaChange: PromiseOrValue<BigNumberish>,
    deltaIncrease: PromiseOrValue<boolean>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  futuresPoolHedgerParams(
    overrides?: CallOverrides
  ): Promise<
    [BigNumber, BigNumber, BigNumber, BigNumber, BigNumber] & {
      maximumDelta: BigNumber;
      maximumFundingRatePerDelta: BigNumber;
      deltaThreshold: BigNumber;
      marketDepthBuffer: BigNumber;
      minKeeperGas: BigNumber;
    }
  >;

  getCappedExpectedHedge(overrides?: CallOverrides): Promise<BigNumber>;

  getCurrentHedgedNetDelta(overrides?: CallOverrides): Promise<BigNumber>;

  getExecutionFee(overrides?: CallOverrides): Promise<BigNumber>;

  getHedgingLiquidity(
    spotPrice: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides
  ): Promise<
    [BigNumber, BigNumber] & {
      pendingDeltaLiquidity: BigNumber;
      usedDeltaLiquidity: BigNumber;
    }
  >;

  getPoolHedgerParams(
    overrides?: CallOverrides
  ): Promise<PoolHedger.PoolHedgerParametersStructOutput>;

  getPosition(overrides?: CallOverrides): Promise<BigNumber[]>;

  gmxPositionCallback(
    positionKey: PromiseOrValue<BytesLike>,
    isExecuted: PromiseOrValue<boolean>,
    isIncrease: PromiseOrValue<boolean>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  greekCache(overrides?: CallOverrides): Promise<string>;

  hedgeDelta(
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  indexToken(overrides?: CallOverrides): Promise<string>;

  init(
    _liquidityPool: PromiseOrValue<string>,
    _greekCache: PromiseOrValue<string>,
    _router: PromiseOrValue<string>,
    _reader: PromiseOrValue<string>,
    _baseRouter: PromiseOrValue<string>,
    _vaultUtils: PromiseOrValue<string>,
    _quoteAsset: PromiseOrValue<string>,
    _indexToken: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  isLong(overrides?: CallOverrides): Promise<boolean>;

  lastInteraction(overrides?: CallOverrides): Promise<BigNumber>;

  nominateNewOwner(
    _owner: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  nominatedOwner(overrides?: CallOverrides): Promise<string>;

  orderQueue(
    arg0: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides
  ): Promise<
    [boolean, BigNumber, BigNumber, boolean, number, boolean, string] & {
      isIncrease: boolean;
      collateralDelta: BigNumber;
      sizeDelta: BigNumber;
      long: boolean;
      status: number;
      useBase: boolean;
      key: string;
    }
  >;

  owner(overrides?: CallOverrides): Promise<string>;

  processQueue(
    overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  quoteAsset(overrides?: CallOverrides): Promise<string>;

  reader(overrides?: CallOverrides): Promise<string>;

  resetInteractionDelay(
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  router(overrides?: CallOverrides): Promise<string>;

  setFuturesPoolHedgerParameters(
    _futuresPoolHedgerParams: IFuturesPoolHedger.FuturesPoolHedgerParametersStruct,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  setMaxLeverage(
    _targetLeverage: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  setPoolHedgerParams(
    _poolHedgerParams: PoolHedger.PoolHedgerParametersStruct,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  targetLeverage(overrides?: CallOverrides): Promise<BigNumber>;

  tradingFee(overrides?: CallOverrides): Promise<BigNumber>;

  updateCollateral(
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  vault(overrides?: CallOverrides): Promise<string>;

  vaultUtils(overrides?: CallOverrides): Promise<string>;

  callStatic: {
    acceptOwnership(overrides?: CallOverrides): Promise<void>;

    canHedge(
      poolDeltaChange: PromiseOrValue<BigNumberish>,
      deltaIncrease: PromiseOrValue<boolean>,
      overrides?: CallOverrides
    ): Promise<boolean>;

    futuresPoolHedgerParams(
      overrides?: CallOverrides
    ): Promise<
      [BigNumber, BigNumber, BigNumber, BigNumber, BigNumber] & {
        maximumDelta: BigNumber;
        maximumFundingRatePerDelta: BigNumber;
        deltaThreshold: BigNumber;
        marketDepthBuffer: BigNumber;
        minKeeperGas: BigNumber;
      }
    >;

    getCappedExpectedHedge(overrides?: CallOverrides): Promise<BigNumber>;

    getCurrentHedgedNetDelta(overrides?: CallOverrides): Promise<BigNumber>;

    getExecutionFee(overrides?: CallOverrides): Promise<BigNumber>;

    getHedgingLiquidity(
      spotPrice: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<
      [BigNumber, BigNumber] & {
        pendingDeltaLiquidity: BigNumber;
        usedDeltaLiquidity: BigNumber;
      }
    >;

    getPoolHedgerParams(
      overrides?: CallOverrides
    ): Promise<PoolHedger.PoolHedgerParametersStructOutput>;

    getPosition(overrides?: CallOverrides): Promise<BigNumber[]>;

    gmxPositionCallback(
      positionKey: PromiseOrValue<BytesLike>,
      isExecuted: PromiseOrValue<boolean>,
      isIncrease: PromiseOrValue<boolean>,
      overrides?: CallOverrides
    ): Promise<void>;

    greekCache(overrides?: CallOverrides): Promise<string>;

    hedgeDelta(overrides?: CallOverrides): Promise<void>;

    indexToken(overrides?: CallOverrides): Promise<string>;

    init(
      _liquidityPool: PromiseOrValue<string>,
      _greekCache: PromiseOrValue<string>,
      _router: PromiseOrValue<string>,
      _reader: PromiseOrValue<string>,
      _baseRouter: PromiseOrValue<string>,
      _vaultUtils: PromiseOrValue<string>,
      _quoteAsset: PromiseOrValue<string>,
      _indexToken: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<void>;

    isLong(overrides?: CallOverrides): Promise<boolean>;

    lastInteraction(overrides?: CallOverrides): Promise<BigNumber>;

    nominateNewOwner(
      _owner: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<void>;

    nominatedOwner(overrides?: CallOverrides): Promise<string>;

    orderQueue(
      arg0: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<
      [boolean, BigNumber, BigNumber, boolean, number, boolean, string] & {
        isIncrease: boolean;
        collateralDelta: BigNumber;
        sizeDelta: BigNumber;
        long: boolean;
        status: number;
        useBase: boolean;
        key: string;
      }
    >;

    owner(overrides?: CallOverrides): Promise<string>;

    processQueue(overrides?: CallOverrides): Promise<void>;

    quoteAsset(overrides?: CallOverrides): Promise<string>;

    reader(overrides?: CallOverrides): Promise<string>;

    resetInteractionDelay(overrides?: CallOverrides): Promise<void>;

    router(overrides?: CallOverrides): Promise<string>;

    setFuturesPoolHedgerParameters(
      _futuresPoolHedgerParams: IFuturesPoolHedger.FuturesPoolHedgerParametersStruct,
      overrides?: CallOverrides
    ): Promise<void>;

    setMaxLeverage(
      _targetLeverage: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<void>;

    setPoolHedgerParams(
      _poolHedgerParams: PoolHedger.PoolHedgerParametersStruct,
      overrides?: CallOverrides
    ): Promise<void>;

    targetLeverage(overrides?: CallOverrides): Promise<BigNumber>;

    tradingFee(overrides?: CallOverrides): Promise<BigNumber>;

    updateCollateral(overrides?: CallOverrides): Promise<void>;

    vault(overrides?: CallOverrides): Promise<string>;

    vaultUtils(overrides?: CallOverrides): Promise<string>;
  };

  filters: {
    "ApprovalsUpdated(bool)"(state?: null): ApprovalsUpdatedEventFilter;
    ApprovalsUpdated(state?: null): ApprovalsUpdatedEventFilter;

    "CollateralOrderPosted(bytes32)"(
      positionKey?: null
    ): CollateralOrderPostedEventFilter;
    CollateralOrderPosted(positionKey?: null): CollateralOrderPostedEventFilter;

    "CollateralUpdated(uint256,uint256)"(
      newCollat?: null,
      oldCollat?: null
    ): CollateralUpdatedEventFilter;
    CollateralUpdated(
      newCollat?: null,
      oldCollat?: null
    ): CollateralUpdatedEventFilter;

    "GasLimitToLow(uint256)"(gasLimit?: null): GasLimitToLowEventFilter;
    GasLimitToLow(gasLimit?: null): GasLimitToLowEventFilter;

    "MaxLeverageSet(uint256)"(newShortBuffer?: null): MaxLeverageSetEventFilter;
    MaxLeverageSet(newShortBuffer?: null): MaxLeverageSetEventFilter;

    "MultiplePositionsOpen(uint256)"(
      length?: null
    ): MultiplePositionsOpenEventFilter;
    MultiplePositionsOpen(length?: null): MultiplePositionsOpenEventFilter;

    "OrderExecuted(bytes32,bool,bool)"(
      positionKey?: null,
      isExecuted?: null,
      isIncrease?: null
    ): OrderExecutedEventFilter;
    OrderExecuted(
      positionKey?: null,
      isExecuted?: null,
      isIncrease?: null
    ): OrderExecutedEventFilter;

    "OrderPosted(bytes32,uint256,uint256,bool,bool,bool)"(
      positionKey?: null,
      collateralDelta?: null,
      sizeDelta?: null,
      isLong?: null,
      usedBase?: null,
      isIncrease?: null
    ): OrderPostedEventFilter;
    OrderPosted(
      positionKey?: null,
      collateralDelta?: null,
      sizeDelta?: null,
      isLong?: null,
      usedBase?: null,
      isIncrease?: null
    ): OrderPostedEventFilter;

    "OwnerChanged(address,address)"(
      oldOwner?: null,
      newOwner?: null
    ): OwnerChangedEventFilter;
    OwnerChanged(oldOwner?: null, newOwner?: null): OwnerChangedEventFilter;

    "OwnerNominated(address)"(newOwner?: null): OwnerNominatedEventFilter;
    OwnerNominated(newOwner?: null): OwnerNominatedEventFilter;

    "PoolHedgerParametersSet(tuple)"(
      poolHedgerParams?: null
    ): PoolHedgerParametersSetEventFilter;
    PoolHedgerParametersSet(
      poolHedgerParams?: null
    ): PoolHedgerParametersSetEventFilter;

    "PositionUpdated(int256,int256,int256)"(
      oldNetDelta?: null,
      currentNetDelta?: null,
      expectedNetDelta?: null
    ): PositionUpdatedEventFilter;
    PositionUpdated(
      oldNetDelta?: null,
      currentNetDelta?: null,
      expectedNetDelta?: null
    ): PositionUpdatedEventFilter;

    "QueueNotEmpty(uint256)"(length?: null): QueueNotEmptyEventFilter;
    QueueNotEmpty(length?: null): QueueNotEmptyEventFilter;

    "QuoteReturnedToLP(uint256)"(
      amountQuote?: null
    ): QuoteReturnedToLPEventFilter;
    QuoteReturnedToLP(amountQuote?: null): QuoteReturnedToLPEventFilter;
  };

  estimateGas: {
    acceptOwnership(
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    canHedge(
      poolDeltaChange: PromiseOrValue<BigNumberish>,
      deltaIncrease: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    futuresPoolHedgerParams(overrides?: CallOverrides): Promise<BigNumber>;

    getCappedExpectedHedge(overrides?: CallOverrides): Promise<BigNumber>;

    getCurrentHedgedNetDelta(overrides?: CallOverrides): Promise<BigNumber>;

    getExecutionFee(overrides?: CallOverrides): Promise<BigNumber>;

    getHedgingLiquidity(
      spotPrice: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    getPoolHedgerParams(overrides?: CallOverrides): Promise<BigNumber>;

    getPosition(overrides?: CallOverrides): Promise<BigNumber>;

    gmxPositionCallback(
      positionKey: PromiseOrValue<BytesLike>,
      isExecuted: PromiseOrValue<boolean>,
      isIncrease: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    greekCache(overrides?: CallOverrides): Promise<BigNumber>;

    hedgeDelta(
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    indexToken(overrides?: CallOverrides): Promise<BigNumber>;

    init(
      _liquidityPool: PromiseOrValue<string>,
      _greekCache: PromiseOrValue<string>,
      _router: PromiseOrValue<string>,
      _reader: PromiseOrValue<string>,
      _baseRouter: PromiseOrValue<string>,
      _vaultUtils: PromiseOrValue<string>,
      _quoteAsset: PromiseOrValue<string>,
      _indexToken: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    isLong(overrides?: CallOverrides): Promise<BigNumber>;

    lastInteraction(overrides?: CallOverrides): Promise<BigNumber>;

    nominateNewOwner(
      _owner: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    nominatedOwner(overrides?: CallOverrides): Promise<BigNumber>;

    orderQueue(
      arg0: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    owner(overrides?: CallOverrides): Promise<BigNumber>;

    processQueue(
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    quoteAsset(overrides?: CallOverrides): Promise<BigNumber>;

    reader(overrides?: CallOverrides): Promise<BigNumber>;

    resetInteractionDelay(
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    router(overrides?: CallOverrides): Promise<BigNumber>;

    setFuturesPoolHedgerParameters(
      _futuresPoolHedgerParams: IFuturesPoolHedger.FuturesPoolHedgerParametersStruct,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    setMaxLeverage(
      _targetLeverage: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    setPoolHedgerParams(
      _poolHedgerParams: PoolHedger.PoolHedgerParametersStruct,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    targetLeverage(overrides?: CallOverrides): Promise<BigNumber>;

    tradingFee(overrides?: CallOverrides): Promise<BigNumber>;

    updateCollateral(
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    vault(overrides?: CallOverrides): Promise<BigNumber>;

    vaultUtils(overrides?: CallOverrides): Promise<BigNumber>;
  };

  populateTransaction: {
    acceptOwnership(
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    canHedge(
      poolDeltaChange: PromiseOrValue<BigNumberish>,
      deltaIncrease: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    futuresPoolHedgerParams(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    getCappedExpectedHedge(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    getCurrentHedgedNetDelta(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    getExecutionFee(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    getHedgingLiquidity(
      spotPrice: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    getPoolHedgerParams(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    getPosition(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    gmxPositionCallback(
      positionKey: PromiseOrValue<BytesLike>,
      isExecuted: PromiseOrValue<boolean>,
      isIncrease: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    greekCache(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    hedgeDelta(
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    indexToken(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    init(
      _liquidityPool: PromiseOrValue<string>,
      _greekCache: PromiseOrValue<string>,
      _router: PromiseOrValue<string>,
      _reader: PromiseOrValue<string>,
      _baseRouter: PromiseOrValue<string>,
      _vaultUtils: PromiseOrValue<string>,
      _quoteAsset: PromiseOrValue<string>,
      _indexToken: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    isLong(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    lastInteraction(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    nominateNewOwner(
      _owner: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    nominatedOwner(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    orderQueue(
      arg0: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    owner(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    processQueue(
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    quoteAsset(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    reader(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    resetInteractionDelay(
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    router(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    setFuturesPoolHedgerParameters(
      _futuresPoolHedgerParams: IFuturesPoolHedger.FuturesPoolHedgerParametersStruct,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    setMaxLeverage(
      _targetLeverage: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    setPoolHedgerParams(
      _poolHedgerParams: PoolHedger.PoolHedgerParametersStruct,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    targetLeverage(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    tradingFee(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    updateCollateral(
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    vault(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    vaultUtils(overrides?: CallOverrides): Promise<PopulatedTransaction>;
  };
}
